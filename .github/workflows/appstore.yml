name: App Store Release

on:
  workflow_dispatch:

env:
  GO_VERSION: '1.24'
  NODE_VERSION: '20'
  APP_NAME: 'ProcHub'

jobs:
  appstore:
    name: Build & Upload to App Store Connect
    runs-on: macos-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from app.go
        run: |
          VERSION=$(sed -n 's/.*Version:[[:space:]]*"v\([^"]*\)".*/\1/p' app.go | head -1)
          echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
          echo "Version: $VERSION"

      - name: Compute build number
        run: |
          VER="${{ env.APP_VERSION }}"
          MAJOR=$(echo "$VER" | cut -d. -f1)
          MINOR=$(echo "$VER" | cut -d. -f2)
          PATCH=$(echo "$VER" | cut -d. -f3)
          BUILD_NUMBER=$(printf "%02d%02d%02d" "$MAJOR" "$MINOR" "$PATCH")
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "Build number: $BUILD_NUMBER"

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm install

      # ------------------------------------------------------------------ #
      # 1. Import certificates into a temporary keychain
      #
      # Required secrets:
      #   CORP_MACOS_DIST_CERTIFICATE              – "Apple Distribution" cert (base64 p12)
      #   CORP_MACOS_DIST_CERTIFICATE_PASSWORD     – p12 password
      #   CORP_MACOS_INSTALLER_CERTIFICATE         – "3rd Party Mac Developer Installer" cert (base64 p12)
      #   CORP_MACOS_INSTALLER_CERTIFICATE_PASSWORD – p12 password
      #   CORP_MACOS_PROVISION_PROFILE             – Mac App Distribution provisioning profile (base64)
      # ------------------------------------------------------------------ #
      - name: Import signing certificates
        env:
          CORP_MACOS_DIST_CERTIFICATE: ${{ secrets.CORP_MACOS_DIST_CERTIFICATE }}
          CORP_MACOS_DIST_CERTIFICATE_PASSWORD: ${{ secrets.CORP_MACOS_DIST_CERTIFICATE_PASSWORD }}
          CORP_MACOS_INSTALLER_CERTIFICATE: ${{ secrets.CORP_MACOS_INSTALLER_CERTIFICATE }}
          CORP_MACOS_INSTALLER_CERTIFICATE_PASSWORD: ${{ secrets.CORP_MACOS_INSTALLER_CERTIFICATE_PASSWORD }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import Apple Distribution cert
          echo "$CORP_MACOS_DIST_CERTIFICATE" | base64 --decode > $RUNNER_TEMP/dist.p12
          security import $RUNNER_TEMP/dist.p12 \
            -P "$CORP_MACOS_DIST_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k $KEYCHAIN_PATH

          # Import Mac Installer Distribution cert
          echo "$CORP_MACOS_INSTALLER_CERTIFICATE" | base64 --decode > $RUNNER_TEMP/installer.p12
          security import $RUNNER_TEMP/installer.p12 \
            -P "$CORP_MACOS_INSTALLER_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k $KEYCHAIN_PATH

          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Resolve signing identities
          DIST_IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH \
            | grep "Apple Distribution" | head -1 | awk -F'"' '{print $2}')
          INSTALLER_IDENTITY=$(security find-identity -v -p basic $KEYCHAIN_PATH \
            | grep -E "Mac Installer Distribution|3rd Party Mac Developer Installer" | head -1 | awk -F'"' '{print $2}')

          echo "DIST_IDENTITY=$DIST_IDENTITY"         >> $GITHUB_ENV
          echo "INSTALLER_IDENTITY=$INSTALLER_IDENTITY" >> $GITHUB_ENV
          echo "App signing identity    : $DIST_IDENTITY"
          echo "Installer signing identity: $INSTALLER_IDENTITY"

      # ------------------------------------------------------------------ #
      # 2. Build with Wails
      # ------------------------------------------------------------------ #
      - name: Build app
        run: |
          wails build -platform darwin/universal -trimpath -ldflags "-s -w"

      # ------------------------------------------------------------------ #
      # 3. Inject version & build number into Info.plist
      # ------------------------------------------------------------------ #
      - name: Set version in Info.plist
        run: |
          PLIST="build/bin/${{ env.APP_NAME }}.app/Contents/Info.plist"
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString ${{ env.APP_VERSION }}" "$PLIST"
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion ${{ env.BUILD_NUMBER }}"         "$PLIST"
          echo "Version set to ${{ env.APP_VERSION }} (${{ env.BUILD_NUMBER }})"

      # ------------------------------------------------------------------ #
      # 4. Embed provisioning profile
      #    Required to pass TestFlight validation (ITMS-90889).
      #    Must happen BEFORE codesign so the profile is included in the
      #    code signature. --deep would strip it, so we sign inside-out.
      # ------------------------------------------------------------------ #
      - name: Embed provisioning profile
        env:
          CORP_MACOS_PROVISION_PROFILE: ${{ secrets.CORP_MACOS_PROVISION_PROFILE }}
        run: |
          APP_PATH="build/bin/${{ env.APP_NAME }}.app"
          echo "$CORP_MACOS_PROVISION_PROFILE" | base64 --decode \
            > "$APP_PATH/Contents/embedded.provisionprofile"
          echo "Provisioning profile embedded:"
          ls -lh "$APP_PATH/Contents/embedded.provisionprofile"

      # ------------------------------------------------------------------ #
      # 5. Sign the .app with Apple Distribution certificate
      #    Inside-out order (frameworks → helpers → bundle) is required.
      #    Do NOT use --deep: it re-signs nested content and can invalidate
      #    the embedded provisioning profile.
      # ------------------------------------------------------------------ #
      - name: Sign app bundle
        run: |
          APP_PATH="build/bin/${{ env.APP_NAME }}.app"
          ENTITLEMENTS="build/darwin/entitlements.plist"

          # 1. Sign nested frameworks
          find "$APP_PATH/Contents/Frameworks" \
            \( -name "*.framework" -o -name "*.dylib" \) 2>/dev/null | \
            while read lib; do
              codesign --force --options runtime \
                --entitlements "$ENTITLEMENTS" \
                --sign "$DIST_IDENTITY" "$lib" || true
            done

          # 2. Sign helper binaries (everything in MacOS/ except the main executable)
          find "$APP_PATH/Contents/MacOS" -type f \
            ! -name "${{ env.APP_NAME }}" 2>/dev/null | \
            while read bin; do
              codesign --force --options runtime \
                --entitlements "$ENTITLEMENTS" \
                --sign "$DIST_IDENTITY" "$bin" || true
            done

          # 3. Sign the main app bundle last (covers everything not yet signed)
          codesign --force --options runtime \
            --entitlements "$ENTITLEMENTS" \
            --sign "$DIST_IDENTITY" \
            "$APP_PATH"

          # Verify
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"
          # Assert profile is still present after signing
          test -f "$APP_PATH/Contents/embedded.provisionprofile" || \
            { echo "ERROR: embedded.provisionprofile missing after codesign!"; exit 1; }
          # Confirm sandbox entitlement
          codesign -d --entitlements - "$APP_PATH/Contents/MacOS/${{ env.APP_NAME }}" | grep app-sandbox
          echo "App bundle signed and provisioning profile verified"

      # ------------------------------------------------------------------ #
      # 6. Package into .pkg with productbuild
      # ------------------------------------------------------------------ #
      - name: Create PKG installer
        run: |
          PKG_NAME="${{ env.APP_NAME }}-${{ env.APP_VERSION }}-universal.pkg"
          APP_PATH="build/bin/${{ env.APP_NAME }}.app"

          if [ -z "$INSTALLER_IDENTITY" ]; then
            echo "ERROR: INSTALLER_IDENTITY is empty. Check that CORP_MACOS_INSTALLER_CERTIFICATE is set correctly."
            security find-identity -v -p basic $RUNNER_TEMP/app-signing.keychain-db || true
            exit 1
          fi
          echo "Using installer identity: $INSTALLER_IDENTITY"

          productbuild \
            --component "$APP_PATH" /Applications \
            --sign "$INSTALLER_IDENTITY" \
            "$PKG_NAME"

          echo "PKG_NAME=$PKG_NAME" >> $GITHUB_ENV
          echo "PKG created: $PKG_NAME"

      # ------------------------------------------------------------------ #
      # 7. Verify PKG signature
      # ------------------------------------------------------------------ #
      - name: Verify PKG signature
        run: |
          pkgutil --check-signature "${{ env.PKG_NAME }}"
          echo "PKG signature verified"

      # ------------------------------------------------------------------ #
      # 8. Upload PKG to App Store Connect (TestFlight / App Review)
      #
      # Uses xcrun altool (available without extra install).
      # Alternatively set USE_NOTARYTOOL=true to use notarytool upload.
      # ------------------------------------------------------------------ #
      - name: Upload to App Store Connect
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          BUNDLE_ID: ${{ secrets.BUNDLE_ID }}
          APPLE_APP_ID: ${{ secrets.APPLE_APP_ID }}
        run: |
          echo "Uploading ${{ env.PKG_NAME }} to App Store Connect..."
          xcrun altool --upload-package "${{ env.PKG_NAME }}" \
            --type macos \
            --apple-id "$APPLE_APP_ID" \
            --bundle-id "$BUNDLE_ID" \
            --bundle-version "${{ env.BUILD_NUMBER }}" \
            --bundle-short-version-string "${{ env.APP_VERSION }}" \
            --username "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --asc-provider "$APPLE_TEAM_ID" \
            --verbose
          echo "Upload complete — check App Store Connect for processing status"

      # ------------------------------------------------------------------ #
      # 9. Save PKG as workflow artifact (optional backup)
      # ------------------------------------------------------------------ #

      - name: Upload PKG artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-appstore-universal-${{ env.APP_VERSION }}
          path: ${{ env.PKG_NAME }}
          retention-days: 14
